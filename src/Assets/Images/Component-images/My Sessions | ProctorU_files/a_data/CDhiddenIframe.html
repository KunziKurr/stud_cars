<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"></head><body><script type="text/javascript">/*! $Rev: 4880 $ */
var _walkmeEv = {
    Ev: function(src) {
    return /*allowFunc*/eval(src);
    }
};

(function(){
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/consts.js ###*/
						var TEST_CONNECTION_STRING = "WalkMe_testStorage",
	CROSS_DOMAIN_METHOD = {
		Cookies : 'cookies',
		LocalStorage : 'localStorage',
		IndexedDB : 'indexedDB'
	};

var ORIGIN_MESSAGE = 'frameOrigin';
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/consts.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/di.js ###*/
						var DI = {};
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/di.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/json.js ###*/
						// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (typeof /*allowFunc*/JSON !== 'object') {
    /*allowFunc*/JSON = {};
}

(function () {
    'use strict';

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function () {

            return isFinite(this.valueOf())
                ? this.getUTCFullYear()     + '-' +
                    f(this.getUTCMonth() + 1) + '-' +
                    f(this.getUTCDate())      + 'T' +
                    f(this.getUTCHours())     + ':' +
                    f(this.getUTCMinutes())   + ':' +
                    f(this.getUTCSeconds())   + 'Z'
                : null;
        };

        String.prototype.toJSON      =
            Number.prototype.toJSON  =
            Boolean.prototype.toJSON = function () {
                return this.valueOf();
            };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
            var c = meta[a];
            return typeof c === 'string'
                ? c
                : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0
                    ? '[]'
                    : gap
                    ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'
                    : '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    if (typeof rep[i] === 'string') {
                        k = rep[i];
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0
                ? '{}'
                : gap
                ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'
                : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof /*allowFunc*/JSON.stringify !== 'function') {
        /*allowFunc*/JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                    typeof replacer.length !== 'number')) {
                throw new Error('stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof /*allowFunc*/JSON.parse !== 'function') {
        /*allowFunc*/JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
                    .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
                        .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
                        .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = _walkmeEv.Ev('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function'
                    ? walk({'': j}, '')
                    : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('parse');
        };
    }
}());
    
    /* JSON library - End */

var _json = /*allowFunc*/JSON;
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/json.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/lz-string.js ###*/
						// Copyright (c) 2013 Pieroxy <pieroxy@pieroxy.net>
// This work is free. You can redistribute it and/or modify it
// under the terms of the WTFPL, Version 2
// For more information see LICENSE.txt or http://www.wtfpl.net/
//
// For more information, the home page:
// http://pieroxy.net/blog/pages/lz-string/testing.html
//
// LZ-based compression algorithm, version 1.4.4
var LZString = (function() {

// private property
var f = String.fromCharCode;
// var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};

function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i=0 ; i<alphabet.length ; i++) {
      baseReverseDic[alphabet][alphabet.charAt(i)] = i;
    }
  }
  return baseReverseDic[alphabet][character];
}

var LZString = {
  // compressToBase64 : function (input) {
  //   if (input == null) return "";
  //   var res = LZString._compress(input, 6, function(a){return keyStrBase64.charAt(a);});
  //   switch (res.length % 4) { // To produce valid Base64
  //   default: // When could this happen ?
  //   case 0 : return res;
  //   case 1 : return res+"===";
  //   case 2 : return res+"==";
  //   case 3 : return res+"=";
  //   }
  // },

  // decompressFromBase64 : function (input) {
  //   if (input == null) return "";
  //   if (input == "") return null;
  //   return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrBase64, input.charAt(index)); });
  // },

  // compressToUTF16 : function (input) {
  //   if (input == null) return "";
  //   return LZString._compress(input, 15, function(a){return f(a+32);}) + " ";
  // },

  // decompressFromUTF16: function (compressed) {
  //   if (compressed == null) return "";
  //   if (compressed == "") return null;
  //   return LZString._decompress(compressed.length, 16384, function(index) { return compressed.charCodeAt(index) - 32; });
  // },

  //compress into uint8array (UCS-2 big endian format)
  // compressToUint8Array: function (uncompressed) {
  //   var compressed = LZString.compress(uncompressed);
  //   var buf=new Uint8Array(compressed.length*2); // 2 bytes per character

  //   for (var i=0, TotalLen=compressed.length; i<TotalLen; i++) {
  //     var current_value = compressed.charCodeAt(i);
  //     buf[i*2] = current_value >>> 8;
  //     buf[i*2+1] = current_value % 256;
  //   }
  //   return buf;
  // },

  //decompress from uint8array (UCS-2 big endian format)
  // decompressFromUint8Array:function (compressed) {
  //   if (compressed===null || compressed===undefined){
  //       return LZString.decompress(compressed);
  //   } else {
  //       var buf=new Array(compressed.length/2); // 2 bytes per character
  //       for (var i=0, TotalLen=buf.length; i<TotalLen; i++) {
  //         buf[i]=compressed[i*2]*256+compressed[i*2+1];
  //       }

  //       var result = [];
  //       buf.forEach(function (c) {
  //         result.push(f(c));
  //       });
  //       return LZString.decompress(result.join(''));

  //   }

  // },


  //compress into a string that is already URI encoded
  compressToEncodedURIComponent: function (input) {
    if (input == null) return "";
    return LZString._compress(input, 6, function(a){return keyStrUriSafe.charAt(a);});
  },

  //decompress from an output of compressToEncodedURIComponent
  decompressFromEncodedURIComponent:function (input) {
    if (input == null) return "";
    if (input == "") return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) { return getBaseValue(keyStrUriSafe, input.charAt(index)); });
  },

  compress: function (uncompressed) {
    return LZString._compress(uncompressed, 16, function(a){return f(a);});
  },
  _compress: function (uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null) return "";
    var i, value,
        context_dictionary= {},
        context_dictionaryToCreate= {},
        context_c="",
        context_wc="",
        context_w="",
        context_enlargeIn= 2, // Compensate for the first entry which should not count
        context_dictSize= 3,
        context_numBits= 2,
        context_data=[],
        context_data_val=0,
        context_data_position=0,
        ii;

    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary,context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }

      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary,context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
          if (context_w.charCodeAt(0)<256) {
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<8 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i=0 ; i<context_numBits ; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position ==bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i=0 ; i<16 ; i++) {
              context_data_val = (context_data_val << 1) | (value&1);
              if (context_data_position == bitsPerChar-1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }


        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        // Add wc to the dictionary.
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }

    // Output the code for w.
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate,context_w)) {
        if (context_w.charCodeAt(0)<256) {
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<8 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i=0 ; i<context_numBits ; i++) {
            context_data_val = (context_data_val << 1) | value;
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i=0 ; i<16 ; i++) {
            context_data_val = (context_data_val << 1) | (value&1);
            if (context_data_position == bitsPerChar-1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i=0 ; i<context_numBits ; i++) {
          context_data_val = (context_data_val << 1) | (value&1);
          if (context_data_position == bitsPerChar-1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }


      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }

    // Mark the end of the stream
    value = 2;
    for (i=0 ; i<context_numBits ; i++) {
      context_data_val = (context_data_val << 1) | (value&1);
      if (context_data_position == bitsPerChar-1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }

    // Flush the last char
    while (true) {
      context_data_val = (context_data_val << 1);
      if (context_data_position == bitsPerChar-1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      }
      else context_data_position++;
    }
    return context_data.join('');
  },

  decompress: function (compressed) {
    if (compressed == null) return "";
    if (compressed == "") return null;
    return LZString._decompress(compressed.length, 32768, function(index) { return compressed.charCodeAt(index); });
  },

  _decompress: function (length, resetValue, getNextValue) {
    var dictionary = [],
        next,
        enlargeIn = 4,
        dictSize = 4,
        numBits = 3,
        entry = "",
        result = [],
        i,
        w,
        bits, resb, maxpower, power,
        c,
        data = {val:getNextValue(0), position:resetValue, index:1};

    for (i = 0; i < 3; i += 1) {
      dictionary[i] = i;
    }

    bits = 0;
    maxpower = 4; //Math.pow(2,2);
    power=1;
    while (power!=maxpower) {
      resb = data.val & data.position;
      data.position >>= 1;
      if (data.position == 0) {
        data.position = resetValue;
        data.val = getNextValue(data.index++);
      }
      bits |= (resb>0 ? 1 : 0) * power;
      power <<= 1;
    }

    switch (next = bits) {
      case 0:
          bits = 0;
          maxpower = 256; //Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 1:
          bits = 0;
          maxpower = 65536; //Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data.index > length) {
        return "";
      }

      bits = 0;
      maxpower = Math.pow(2,numBits);
      power=1;
      while (power!=maxpower) {
        resb = data.val & data.position;
        data.position >>= 1;
        if (data.position == 0) {
          data.position = resetValue;
          data.val = getNextValue(data.index++);
        }
        bits |= (resb>0 ? 1 : 0) * power;
        power <<= 1;
      }

      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = 256; //Math.pow(2,8);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }

          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = 65536; //Math.pow(2,16);
          power=1;
          while (power!=maxpower) {
            resb = data.val & data.position;
            data.position >>= 1;
            if (data.position == 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
            }
            bits |= (resb>0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize-1;
          enlargeIn--;
          break;
        case 2:
          return result.join('');
      }

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);

      // Add w+entry[0] to the dictionary.
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;

      w = entry;

      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }

    }
  }
};
  return LZString;
})();
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/lz-string.js ###*/
    DI.Compressor = LZString;
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/browserDetector.js ###*/
						function getBrowserInfo() {
		//http://www.quirksmode.org/js/detect.html
		var BrowserDetect = {
			init: function() {
				this.browser = this.searchString(this.dataBrowser) || 'An unknown browser';
				this.version = this.searchVersion(navigator.userAgent) || this.searchVersion(navigator.appVersion) || 'an unknown version';
				this.OS = this.searchString(this.dataOS) || 'an unknown OS';
			},
			searchString: function(data) {
				for (var i = 0; i < data.length; i++) {
					var dataString = data[i].string;
					var dataProp = data[i].prop;
					this.versionSearchString = data[i].versionSearch || data[i].identity;
					if (dataString) {
						if (dataString.indexOf(data[i].subString) != -1) return data[i].identity;
					} else if (dataProp) return data[i].identity;
				}
			},
			searchVersion: function(dataString) {
				var index = dataString.indexOf(this.versionSearchString);
				if (index == -1) return;
				return parseFloat(dataString.substring(index + this.versionSearchString.length + 1));
			},
			dataBrowser: [
				{
					string: navigator.userAgent,
					subString: 'Chrome',
					identity: 'Chrome'
				},
				{ string: navigator.userAgent, subString: 'OmniWeb', versionSearch: 'OmniWeb/', identity: 'OmniWeb' },
				{
					string: navigator.vendor,
					subString: 'Apple',
					identity: 'Safari',
					versionSearch: 'Version'
				},
				{
					prop: window.opera,
					identity: 'Opera',
					versionSearch: 'Version'
				},
				{
					string: navigator.vendor,
					subString: 'iCab',
					identity: 'iCab'
				},
				{
					string: navigator.vendor,
					subString: 'KDE',
					identity: 'Konqueror'
				},
				{
					string: navigator.userAgent,
					subString: 'Firefox',
					identity: 'Firefox'
				},
				{
					string: navigator.vendor,
					subString: 'Camino',
					identity: 'Camino'
				},
				{
					// for newer Netscapes (6+)
					string: navigator.userAgent,
					subString: 'Netscape',
					identity: 'Netscape'
				},
				{
					string: navigator.userAgent,
					subString: 'MSIE',
					identity: 'Explorer',
					versionSearch: 'MSIE'
				},
				{
					string: navigator.userAgent,
					subString: 'Trident',
					identity: 'Explorer',
					versionSearch: ' rv'
				},
				{
					string: navigator.userAgent,
					subString: 'Edge',
					identity: 'Edge'
				},
				{
					string: navigator.userAgent,
					subString: 'Gecko',
					identity: 'Mozilla',
					versionSearch: 'rv'
				},
				{
					// for older Netscapes (4-)
					string: navigator.userAgent,
					subString: 'Mozilla',
					identity: 'Netscape',
					versionSearch: 'Mozilla'
				}
			],
			dataOS: [
				{
					string: navigator.platform,
					subString: 'Win',
					identity: 'Windows'
				},
				{
					string: navigator.platform,
					subString: 'Mac',
					identity: 'Mac'
				},
				{
					string: navigator.userAgent,
					subString: 'iPhone',
					identity: 'iPhone/iPod'
				},
				{
					string: navigator.platform,
					subString: 'Linux',
					identity: 'Linux'
				}
			]
		};
		//////////////////////////////////////

		BrowserDetect.init();

		return BrowserDetect;
	}
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/browserDetector.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/generalFunctions.js ###*/
						function logError(message) {
    try {
        /*allowFunc*/console.log('Error: ' + message);
    }
    catch (err) {}
}

function testConnection(storageManager, callback) {
    var failed = function() {
        if (callback) callback(false);
    };

    try {
        storageManager.setItem(TEST_CONNECTION_STRING, TEST_CONNECTION_STRING, TEST_CONNECTION_STRING, function() {
            storageManager.getItem(TEST_CONNECTION_STRING, TEST_CONNECTION_STRING, function(value) {
                storageManager.removeItem(TEST_CONNECTION_STRING, TEST_CONNECTION_STRING, undefined, undefined, true);

                callback(value == TEST_CONNECTION_STRING);
            }, failed, true);
        }, failed, false, true);
    }
    catch (err) {
        failed();
    }
}

function increment(storageManager, userGuid, key, ttl, lastValue, successback, failback) {
    storageManager.getItem(userGuid, key, function(valueObj) {
        valueObj = valueObj || {value : 0};

        if (valueObj.value !== lastValue)
            valueObj.value++;

        valueObj.saveTime = new Date().getTime();
        valueObj.expireSeconds = ttl;

        storageManager.setItem(userGuid, key, valueObj, function() {
            if (successback) successback(valueObj.value);
        }, failback);
    }, failback);
}

function getOrSetAndGet(storageManager, userGuid, key, ttl, fallbackValue, successback, failback) {
    storageManager.getItem(userGuid, key, function(valueObj) {
        if (!valueObj) {
            valueObj = {
                value: _json.stringify(fallbackValue),
                saveTime: new Date().getTime(),
                expireSeconds: ttl
            }
            
            storageManager.setItem(userGuid, key, valueObj, function() {
                if (successback) {
                    successback(fallbackValue);
                }
            }, failback);
        } else {
            if (successback) {
                successback(_json.parse(valueObj.value));
            }
        }
    }, failback);
}

// Due to a bug - when the storage mode is localStorage - we save the data in diffenet keys on the storage,
// each key in the storage is a set of (key : value) pairs, and we save a saveObj that unites all the keys
// and defines the expiration for the dictionary
function addToDictionary(userGuid, dictionaryKey, keyValues, saveObj) {
    // for now this is implemented only in the localStorage manager because it is the only one that
    // has bugs
    // TODO: implement this in an inheritance way
    if (storageManager.addToDictionary) {
        storageManager.setItem(userGuid, dictionaryKey, saveObj, null, null, false);

        for (var key in keyValues) {
            if (keyValues.hasOwnProperty(key)) {
                storageManager.addToDictionary(userGuid, dictionaryKey, key, keyValues[key]);
            }
        }
    }
    else {
        // Here we just get the only dictionary and add the deltas to it, then we update
        // the saveObj that contains the expiration data with the new expiration data
        // TODO: implement this in the base class of the storage managers
        storageManager.getItem(userGuid, dictionaryKey, function(oldObj) {
            var dictionary = {};

            if (oldObj && oldObj.value)
                dictionary = _json.parse(oldObj.value) || {};

            for (var key in keyValues) {
                if (keyValues.hasOwnProperty(key)) {
                    dictionary[key] = keyValues[key];
                }
            }

            saveObj.value = _json.stringify(dictionary);

            storageManager.setItem(userGuid, dictionaryKey, saveObj);
        });
    }
}

function removeFromDictionary(userGuid, dictionaryKey, keysToRemove, saveObj) {
    if (storageManager.removeFromDictionary) {
        storageManager.setItem(userGuid, dictionaryKey, saveObj, null, null, false);

        for (var i = 0; i < keysToRemove.length; i++) {
            storageManager.removeFromDictionary(userGuid, dictionaryKey, keysToRemove[i]);
        }
    }
    else {
        storageManager.getItem(userGuid, dictionaryKey, function(oldObj) {
            var dictionary = {};

            if (oldObj && oldObj.value)
                dictionary = _json.parse(oldObj.value) || {};

            var isChanged = false;

            for (var i = 0; i < keysToRemove.length; i++) {
                var key = keysToRemove[i];

                if (dictionary[key] !== undefined) {
                    delete dictionary[key];
                    isChanged = true;
                }
            }

            if (isChanged) {
                saveObj.value = _json.stringify(dictionary);
                storageManager.setItem(userGuid, dictionaryKey, saveObj);
            }
        });
    }
}

function getAllSavedDataMultiple(userGuid, callback)
{
    var failed = function() {
        if (callback) callback();
    };

    try {
        var allUsersData = {};
        storageManager.getAll(userGuid, function(data) {
            if (data) {
                allUsersData[userGuid] = data;
            }

            if (callback) callback(allUsersData);

        }, failed);
    }
    catch (err) {
        logError(err);
        failed();
    }
}

function addToSet(userGuid, key, saveObj){
    if (storageManager.addToSet) {
        storageManager.addToSet(userGuid, key, saveObj);
    }
    else {
        storageManager.getItem(userGuid, key, function(oldObj) {
            var arr = [];

            if (oldObj && oldObj.value)
                arr = _json.parse(oldObj.value) || [];

            var addedRange = saveObj.value;
            for (var i = 0; i < addedRange.length; i++){
                if (arr.indexOf(addedRange[i]) == -1){
                    arr.push(addedRange[i]);
                }
            }

            saveObj.value = _json.stringify(arr);

            storageManager.setItem(userGuid, key, saveObj);
        });
    }
}
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/generalFunctions.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/cookiesManager.js ###*/
						/* Cookies Manager */
function CookiesManager() {
	var _this = this;
	var _compressor;

	var PATH_COOKIE_PREFIX = ';path=/';
	var DOMAIN_COOKIE_PREFIX = ';domain=';
	var EXPIRES_COOKIE_PREFIX = ';expires=';
	var SECURE_COOKIE_FLAG = ';secure';
	var SAME_SITE_NONE_COOKIE_FLAG = ';SameSite=None';
	var SAME_SITE_LAX_COOKIE_FLAG = ';SameSite=Lax';
	var COOKIE_ASSIGN_VALUE_CHAR = '=';

	var DELETED_COOKIE = '***DEL***';
	var STORAGE_PREFIX = 'WalkMeStorage_';
	var TWO_YEARS = 60 * 60 * 24 * 365 * 2;

	var CHUNK_LENGTH = 4096; //4KB
	var _securityFlag = '';

	function ctor() {
		_compressor = DI.Compressor;

		var borwserInfo = getBrowserInfo();

		// Safari doesn't support SameSite=None
		if (borwserInfo.browser === 'Safari') {
			_securityFlag = isHttps() ? SECURE_COOKIE_FLAG : SAME_SITE_LAX_COOKIE_FLAG;
		}
		else {
			_securityFlag = isHttps() ? SAME_SITE_NONE_COOKIE_FLAG + SECURE_COOKIE_FLAG : SAME_SITE_LAX_COOKIE_FLAG;
		}
	}

	function isHttps() {
		return window.location.protocol === 'https:';
	}

	_this.init = function init(userGuid, successback) {
		if (successback) successback();
	};

	_this.testConnection = function(callback) {
		testConnection(_this, callback);
	};

	this.setItem = function(userGuid, key, value, successback, failback) {
		try {
			var storage = getStorage(userGuid);
			storage[key] = value;
			setStorage(userGuid, storage, TWO_YEARS);

			if (successback) successback();
		} catch (err) {
			if (failback) failback(err);
		}
	};

	this.getItem = function(userGuid, key, successback, failback) {
		try {
			var storage = getStorage(userGuid);
			if (successback) successback(storage[key]);
		} catch (err) {
			if (failback) failback(err);
		}
	};

	this.getAll = function(userGuid, successback, failback) {
		try {
			var storage = getStorage(userGuid);
			var data = [];

			for (var currKey in storage) {
				var currData = storage[currKey];
				if (currData !== undefined) {
					data.push({ key: currKey, saveObj: currData });
				}
			}

			if (successback) successback(data);
		} catch (err) {
			if (failback) failback(err);
		}
	};

	this.removeItem = function(userGuid, key, successback, failback) {
		try {
			var storage = getStorage(userGuid);
			delete storage[key];
			setStorage(userGuid, storage, TWO_YEARS);
			if (successback) successback();
		} catch (err) {
			if (failback) failback(err);
		}
	};

	this.increment = function(userGuid, key, ttl, lastValue, successback, failback) {
		increment(_this, userGuid, key, ttl, lastValue, successback, failback);
	};

	this.getOrSetAndGet = function(userGuid, key, ttl, fallbackValue, successback, failback) {
		getOrSetAndGet(_this, userGuid, key, ttl, fallbackValue, successback, failback);
	};

	function setStorage(guid, storage, expiresSeconds, domain) {
		var storageName = STORAGE_PREFIX + guid;
		clearOldStorageCookiesForGuid(storageName, domain);

		var value = _json.stringify(storage);

		if (_compressor) value = _compressor.compressToEncodedURIComponent(value);

		// save only strings, not numbers
		if (typeof value != 'string') {
			value = value.toString();

			
		}

		if (value.indexOf(';') > -1) {
			

			value.replace(';', '');
		}

		var chunkLengthAfterKey = getChunkFreeSpaceForCookie(storageName, expiresSeconds, domain);
		var valueSplitted = splitSubstring(value, chunkLengthAfterKey);

		for (var cookieIndex = 0; cookieIndex < valueSplitted.length; cookieIndex++) {
			var currCookieVal = valueSplitted[cookieIndex];

			var currCookieKey = storageName;
			if (cookieIndex > 0) {
				currCookieKey += '_' + cookieIndex;
			}

			//set cookie to browser
			setCookieToDocument(currCookieKey, currCookieVal, expiresSeconds, domain);
		}
	}

	function clearOldStorageCookiesForGuid(storageName, domain) {
		var cookieName,
			currCookieIndex,
			ARRcookies = document.cookie.split(';');

		for (currCookieIndex = 0; currCookieIndex < ARRcookies.length; currCookieIndex++) {
			cookieName = ARRcookies[currCookieIndex].substr(0, ARRcookies[currCookieIndex].indexOf('='));
			cookieName = cookieName.replace(/^\s+|\s+$/g, '');

			if (cookieName.indexOf(storageName) === 0) {
				deleteCookieFromDocument(cookieName, domain);
			}
		}
	}

	function getChunkFreeSpaceForCookie(storageName, expiresSeconds, domain) {
		var expiresString = getExpiresString(expiresSeconds);
		var domainString = getDomainString(domain);

		// calcualte the size we have left for the cookie
		var result =
			CHUNK_LENGTH -
			(storageName.length +
			3 + // +3 for up to ('_50').length which is the max amount of cookies a domian allowed
				expiresString.length +
				domainString.length +
				PATH_COOKIE_PREFIX.length);

		return result;
	}

	function setCookieToDocument(key, value, expiresSeconds, domain) {
		var expireString = getExpiresString(expiresSeconds);
		var domainString = getDomainString(domain);

		var cookieValue = value + expireString + PATH_COOKIE_PREFIX + domainString;
		document.cookie = key + COOKIE_ASSIGN_VALUE_CHAR + cookieValue + _securityFlag;
	}

	function deleteCookieFromDocument(cookieName, domain) {
		setCookieToDocument(cookieName, DELETED_COOKIE, TWO_YEARS * -1, domain);
	}

	function getExpiresString(expiresSeconds) {
		var expireString = '';

		// If we entered 0, than we wanted the cookie to last the entire session. negative means delete the cookie
		if (expiresSeconds != 0 && !isNaN(expiresSeconds)) {
			var exdate = new Date();
			exdate.setTime(exdate.getTime() + expiresSeconds * 1000);

			expireString = EXPIRES_COOKIE_PREFIX + exdate.toUTCString();
		}

		return expireString;
	}

	function getDomainString(domain) {
		var domainString = '';
		if (domain && domain.length > 0) {
			domainString = DOMAIN_COOKIE_PREFIX + domain;
		}

		return domainString;
	}

	function splitSubstring(str, len) {
		var result = [];
		for (var offset = 0, strLen = str.length; offset < strLen; offset += len) {
			result.push(str.substring(offset, offset + len));
		}

		return result;
	}

	function getStorage(guid) {
		var storageItemsDict,
			storageItemsString,
			ARRcookies = document.cookie.split(';'),
			storageName = STORAGE_PREFIX + guid;

		storageItemsDict = getStorageItemsDict(ARRcookies, storageName);
		storageItemsString = parseStorageDict(storageItemsDict, storageName);

		if (_compressor) {
			storageItemsString = _compressor.decompressFromEncodedURIComponent(storageItemsString);
		}

		if (!storageItemsString || storageItemsString == DELETED_COOKIE) {
			return {};
		}

		try {
			return _json.parse(storageItemsString) || {};
		} catch (err) {
			return {};
		}
	}

	function getStorageItemsDict(ARRcookies, storageName) {
		var cookieName,
			cookieValue,
			currCookieIndex,
			storageKeysDict = {};

		for (currCookieIndex = 0; currCookieIndex < ARRcookies.length; currCookieIndex++) {
			cookieName = ARRcookies[currCookieIndex].substr(0, ARRcookies[currCookieIndex].indexOf('='));
			cookieValue = ARRcookies[currCookieIndex].substr(ARRcookies[currCookieIndex].indexOf('=') + 1);
			cookieName = cookieName.replace(/^\s+|\s+$/g, '');

			if (cookieName.indexOf(storageName) === 0) {
				storageKeysDict[cookieName] = cookieValue;
			}
		}

		return storageKeysDict;
	}

	function parseStorageDict(storageItemsDict, storageName) {
		var result = '',
			cookieIndex;
		for (cookieIndex = 0; cookieIndex < objectKeysLength(storageItemsDict); cookieIndex++) {
			var currCookieKey =
				cookieIndex === 0
					? storageName // this will enable backwards competability
					: storageName + ('_' + cookieIndex);

			if (storageItemsDict.hasOwnProperty(currCookieKey)) {
				result += storageItemsDict[currCookieKey];
			}
		}

		return result;
	}

	function objectKeysLength(obj) {
		var count = 0;

		for (var prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				count++;
			}
		}

		return count;
	}

	function clearStorage(guid) {
		setStorage(guid, DELETED_COOKIE);
	}

	ctor.apply(null, arguments);
}

						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/cookiesManager.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/localStorageManager.js ###*/
						function LocalStorageManager() {
	
	var _this = this,

		OLD_STORAGE_PREFIX = "WalkMeStorage_",
		STORAGE_PREFIX = "WMS",
		DICTIONARY_REGEX = /\[guid=(.+) dict=(.+) key=([\s\S]+)\]$/,
		NEW_ITEM_REGEX = /\[guid=(.+) key=([\s\S]+)\]$/,
		USER_GUID_INDEX = 1,
		REGULAR_KEY_INDEX = 2,
		KEY_IN_DICTIONARY_INDEX = 3,
		DICTIONARY_KEY_INDEX = 2,

		_localStorage;

	var _cacheValid;

	function ctor() {
	    try {
	        _localStorage = window.localStorage;
	    }
	    catch (err) {
            logError('local storage is blocked by browser settings error=' + err);
	    }
	}

	_this.testConnection = function(callback) {
	    testConnection(_this, callback);
	};

	_this.init = function init(userGuid, successback) {
		try {
            upgradeUserData(userGuid);
		}
		catch(err) {
			logError('error upgrading old data error=' + err);
		}

		bindStorageEvents();

		if (successback) successback();
	};

	function bindStorageEvents() {
		if (window.addEventListener) {
			window.addEventListener("storage", invalidateCache, false);
		} else if (window.attachEvent) {
			document.attachEvent("onstorage", invalidateCache);
		}
	}

	function unbindStorageEvents() {
		if (window.removeEventListener) {
			window.removeEventListener("storage", invalidateCache, false);
		} else if (window.attachEvent) {
			document.detachEvent("onstorage", invalidateCache);
		}
	}

	_this.terminate = function() {
        unbindStorageEvents();
    };

	function invalidateCache() {
	    _cacheValid = false;
	}

	// Upgrading old data to the new format (old - dictionary with all the keys as keys,
	//                                       new - each key is an entry in the local storage)
	function upgradeUserData(guid) {
	    var oldStorageKey = OLD_STORAGE_PREFIX + guid;

	    var oldDataString = _localStorage.getItem(oldStorageKey);

	    if (oldDataString) {
	        var oldData = _json.parse(oldDataString);

	        for(var key in oldData) {
	            if (oldData.hasOwnProperty(key)) {
	                _this.setItem(guid, key, oldData[key]);
	            }
	        }
	    }

	    _localStorage.removeItem(oldStorageKey);
	}

	_this.setItem = function(userGuid, key, value, successback, failback, clearDictionary, isStandaloneKey) {
	    try {
	        var storageKey;

	        if (isStandaloneKey) {
	            storageKey = key;
	        }
	        else {
	            storageKey = createStorageKey(userGuid, key);    
	            addKey(userGuid, storageKey);
	        }
	        
	        _localStorage.setItem(storageKey, _json.stringify(value));

	        if (clearDictionary || clearDictionary === undefined) {
	            removeDictionaryEntries(userGuid, key);
	        }

	        if (successback) successback();
	    }
	    catch (err) {
	        if (failback) failback(err);
	    }
	};

	function removeDictionaryEntries(userGuid, dictionaryKey) {
	    var keys = getStorageKeys(userGuid);

	    // TODO: this happens VERY often when cd_play is on - is it a good idea to run so many regex's?
	    for (var i = 0; i < keys.length; i++) {
	        var storageKey = keys[i];
	        var matches = DICTIONARY_REGEX.exec(storageKey);

	        if (matches && matches[USER_GUID_INDEX] == userGuid && matches[DICTIONARY_KEY_INDEX] == dictionaryKey) {
	            removeKey(userGuid, storageKey);
	            _localStorage.removeItem(storageKey);
	        }
	    }
	}

	this.getItem = function(userGuid, key, successback, failback, isStandaloneKey) {
	    try {
	        var storageKey = isStandaloneKey ? key : createStorageKey(userGuid, key);
	        var value = _localStorage.getItem(storageKey);

	        if (value) value = _json.parse(value);

	        if (successback) successback(value);
	    }
	    catch(err) {
	        if (failback) failback(err);
	    }
	};

	this.getAll = function(userGuid, successback, failback) {
	    if (_cacheValid) {
	    	successback && successback();
	    	return;
	    }

	    try {
	        var data = [];
	        var dictionaries = getDictionaries(userGuid);
	        // TODO: delete old dictionary entries

	        var keys = getStorageKeys(userGuid);
	        // TODO: this happens VERY often when cd_play is on - is it a good idea to run so many regex's?
	        for (var i = 0; i < keys.length; i++) {
	            var storageKey = keys[i];
	            var matches = NEW_ITEM_REGEX.exec(storageKey);

	            if (matches && matches[USER_GUID_INDEX] == userGuid) {
	                var currKey = matches[REGULAR_KEY_INDEX];
	                var currData = _json.parse(_localStorage.getItem(storageKey));

	                if (currKey && currData != undefined)
	                {
	                    if (dictionaries[currKey]) {
	                        currData.value = _json.stringify(dictionaries[currKey]);
	                    }

	                    data.push({key : currKey, saveObj : currData});
	                }
	            }
	        }

	        _cacheValid = true;

	        if (successback) successback(data);
	    }
	    catch (err) {
	        if (failback) failback(err);
	    }
	};

	this.removeItem = function(userGuid, key, successback, failback, isStandaloneKey) {
	    try {
	        var storageKey;

	        if (isStandaloneKey) {
	            storageKey = key;
	        }
	        else {
	            storageKey = createStorageKey(userGuid, key);
	            removeKey(userGuid, storageKey);
	        }

	        _localStorage.removeItem(storageKey);

	        if (!isStandaloneKey) {
	            removeDictionaryEntries(userGuid, key);
	        }

	        if (successback) successback();
	    }
	    catch(err) {
	        if (failback) failback(err);
	    }
	};

	this.increment = function(userGuid, key, ttl, lastValue, successback, failback) {
	    increment(_this, userGuid, key, ttl, lastValue, successback, failback);
	};

	this.getOrSetAndGet = function(userGuid, key, ttl, fallbackValue, successback, failback) {
	    getOrSetAndGet(_this, userGuid, key, ttl, fallbackValue, successback, failback);
	};

	this.addToDictionary = function(userGuid, dictionaryKey, key, value) {
	    var storageKey = createStorageDictionaryKey(userGuid, dictionaryKey, key);
	    addKey(userGuid, storageKey);
	    _localStorage.setItem(storageKey, _json.stringify(value));
	};

	this.removeFromDictionary = function(userGuid, dictionaryKey, key) {
	    var storageKey = createStorageDictionaryKey(userGuid, dictionaryKey, key);
	    removeKey(userGuid, storageKey);
	    _localStorage.removeItem(storageKey);
	};

	function getDictionaries(userGuid, data) {
	    var dictionaries = {};

	    var keys = getStorageKeys(userGuid);
	    // TODO: this happens VERY often when cd_play is on - is it a good idea to run so many regex's?
	    for (var i = 0; i < keys.length; i++) {
	        var storageKey = keys[i];
	        var matches = DICTIONARY_REGEX.exec(storageKey);

	        // 0 - userGuid, 1 - dictionary key, 2 - key in the dictionary
	        if (matches) {
	            if (matches[USER_GUID_INDEX] == userGuid) {
	                if (!dictionaries[matches[DICTIONARY_KEY_INDEX]])
	                    dictionaries[matches[DICTIONARY_KEY_INDEX]] = {};

	                dictionaries[matches[DICTIONARY_KEY_INDEX]][matches[KEY_IN_DICTIONARY_INDEX]] = _json.parse(_localStorage.getItem(storageKey));
	            }
	        }
	    }

	    return dictionaries;
	}

	// TODO: Wrap in a feature and stick it in the trunk

	var OLD_KEYS_SUFFIX = '-keys';
	var KEYS_SUFFIX = "-keysV2";
	var OLD_DELIMITER = ";";
	var DELIMITER = ";|~";
	var OLD_STORAGE_REGEX = new RegExp(OLD_DELIMITER, "g");

	// This will return all the keys - not only for this user
	function getKeysUsingForeach(userGuid) {
	    var keys = [];
	    var key;

	    for (var i = 0; i < _localStorage.length; i++) {
	        key = _localStorage.key(i);
	        var matches = /\[guid=(.+) .+\]$/.exec(key);

	        if (matches && matches[USER_GUID_INDEX] == userGuid) {
	            keys.push(key);
	        }
	    }

	    return keys;
	}

	function getStorageKeys(userGuid) {
	    var keys = _localStorage.getItem(userGuid + KEYS_SUFFIX);

	    /** Can be removed on 01.01.2017 **/
	    if (!keys) {
	        keys = _localStorage.getItem(userGuid + OLD_KEYS_SUFFIX);
	        
	        if (keys) {
	            keys = keys.replace(OLD_STORAGE_REGEX, DELIMITER);
	            _localStorage.removeItem(userGuid + OLD_KEYS_SUFFIX);
	            _localStorage.setItem(userGuid + KEYS_SUFFIX, keys);
	        }
	    }
	    /** End can-be-removed **/

	    if (keys) {
	        keys = keys.split(DELIMITER);
	    }
	    else {
	        keys = getKeysUsingForeach(userGuid);
	        setStorageKeys(userGuid, keys);
	    }

	    return keys;
	}

	function setStorageKeys(userGuid, keys) {
	    _localStorage.setItem(userGuid + KEYS_SUFFIX, keys.join(DELIMITER));
	}

	function addKey(userGuid, key) {
	    var keys = getStorageKeys(userGuid);

	    if (inArray(key, keys) == -1) {
	        keys.push(key);
	        setStorageKeys(userGuid, keys);
	    }
	}

	function removeKey(userGuid, key) {
	    var keys = getStorageKeys(userGuid);

	    var keyIndex = inArray(key, keys);
	    if (keyIndex > -1) {
	        keys.splice(keyIndex, 1);
	        setStorageKeys(userGuid, keys);
	    }
	}

	function inArray(key, arr) {
	    for (var i = 0; i < arr.length; i++) {
	        if (arr[i] == key) return i;
	    }

	    return -1;
	}

	function createStorageKey(userGuid, key) {
	    return STORAGE_PREFIX + '[guid=' + userGuid + ' key=' + key + ']';
	}

	function createStorageDictionaryKey(userGuid, dictionaryKey, key) {
	    return STORAGE_PREFIX + '[guid=' + userGuid + ' dict=' + dictionaryKey + ' key=' + key + ']';
	}

	ctor.apply(null, arguments);
}
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/localStorageManager.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/indexedDbManager.js ###*/
						function IndexedDBManager() {
	var _this = this;

	var _indexedDbWorker;
	var _actionsQueue;
	var _actionNumber = 0;
	var _running = 0;
	var _terminated, _alreadyInit;

	function ctor() {
		_actionsQueue = {
			init: [
				function() {
					_alreadyInit = true;
				}
			]
		};
	}

	_this.init = function init(userGuid, successback) {
		if (!_indexedDbWorker) {
			_indexedDbWorker = new Worker('indexedDbManager.js');

			_indexedDbWorker.onmessage = unqueueAction;

			window.onbeforeunload = waitForTransactionsToFinish;
		}

		if (successback) {
			if (_alreadyInit) successback();
			else _actionsQueue.init.push(successback);
		}
	};

	_this.testConnection = function(callback) {
		if (!callback) return;

		doAction(
			'test',
			TEST_CONNECTION_STRING,
			null,
			function() {
				callback(true);
			},
			function() {
				callback(false);
			}
		);
	};

	_this.terminate = function() {
		_terminated = true;

		if (_indexedDbWorker) _indexedDbWorker.terminate();
	};

	_this.setItem = function(userGuid, key, value, successback, failback, clearDictionary) {
		doAction('set', userGuid, { key: key, value: value, clearDict: clearDictionary }, successback, failback);
	};

	_this.getItem = function(userGuid, key, successback, failback) {
		doAction('get', userGuid, { key: key }, successback, failback);
	};

	_this.getAll = function(userGuid, successback, failback) {
		doAction('all', userGuid, null, successback, failback);
	};

	_this.removeItem = function(userGuid, key, successback, failback) {
		doAction('del', userGuid, { key: key }, successback, failback);
	};

	_this.addToSet = function(userGuid, key, addedRange, successCallback, failCallback) {
		doAction('addSet', userGuid, { key: key, value: addedRange }, successCallback, failCallback);
	};

	this.addToDictionary = function(userGuid, dictionaryKey, key, value, successback, failback) {
		doAction('add', userGuid, { dict: dictionaryKey, key: key, value: value }, successback, failback);
	};

	this.removeFromDictionary = function(userGuid, dictionaryKey, key, successback, failback) {
		doAction('rem', userGuid, { dict: dictionaryKey, key: key }, successback, failback);
	};

	this.increment = function(userGuid, key, ttl, lastValue, successback, failback) {
		doAction('inc', userGuid, { key: key, ttl: ttl, lastValue: lastValue }, successback, failback);
	};

	this.getOrSetAndGet = function(userGuid, key, ttl, fallbackValue, successback, failback) {
		doAction('getOrSet', userGuid, { key: key, ttl: ttl, fallbackValue: fallbackValue }, successback, failback);
	};

	function doAction(action, guid, data, success, failed) {
		incrementAction();

		var actionObj = _json.stringify({
			action: action,
			guid: guid,
			obj: data,
			num: _actionNumber /*,
            // Debug response times
            requestTime : new Date().getTime()*/
		});

		_actionsQueue[_actionNumber] = {
			success: success,
			failed: failed
		};

		_running++;
		_indexedDbWorker.postMessage(actionObj);
	}

	function incrementAction() {
		_actionNumber++;

		if (_actionNumber > 10000) {
			_actionNumber = 0;
		}
	}

	function unqueueAction(event) {
		if (_terminated) return;

		var responseData = _json.parse(event.data);

		if (responseData == 'ready') {
			for (var i = 0; i < _actionsQueue.init.length; i++) {
				_actionsQueue.init[i]();
			}

			_actionsQueue.init.length = 0;
		} else {
			_running--;
			var actionNumber = responseData.num;
			var actions = _actionsQueue[actionNumber];
			delete _actionsQueue[actionNumber];

			if (responseData.success) {
				if (actions && actions.success) actions.success(responseData.obj);
			} else {
				if (actions && actions.failed) actions.failed(responseData.obj);
			}
		}
	}

	function waitForTransactionsToFinish() {
		if (_running > 0) {
			sleep(150);
		}
	}

	function sleep(milliseconds) {
		var start = new Date().getTime();

		for (var i = 0; i < 1e7; i++) {
			if (new Date().getTime() - start > milliseconds) {
				break;
			}
		}
	}

	ctor.apply(null, arguments);
}

						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/indexedDbManager.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/sessionStorageManager.js ###*/
						function SessionStorageManager() {
	var _this = this,
		STORAGE_PREFIX = 'WMS_',
		_sessionStorage;

	function ctor() {
		_sessionStorage = window.sessionStorage;
	}

	_this.set = function(data) {
		var key = STORAGE_PREFIX + data.userGuid + data.key;
		_sessionStorage.setItem(key, data.value);
	};

	_this.get = function(data) {
		var key = STORAGE_PREFIX + data.userGuid + data.key;

		var value = _sessionStorage.getItem(key);

		if (value === undefined) {
			value = data.defaultValue;
		}

		return value;
	};

    ctor.apply(null, arguments);
}

						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/dataManagers/sessionStorageManager.js ###*/

    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/broadcastChannel.js ###*/
						var channel;

function initBroadcastChannel() {
    if (channel) return;

    channel = new BroadcastChannel('wm-channel');
    
    channel.onmessage = function(e) {
        const msg = Object.assign({}, e.data);

        delete msg.toBC;
    
        talkToParent(Object.assign({fromBC: true}, msg));
    }
    
    function talkToParent(msg) {
        window.parent.postMessage(msg, '*');
    }
    
    window.onbeforeunload = function() {
        channel.close();
    };
}
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/broadcastChannel.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/storageManager.js ###*/
						var _saveMode;
var storageManager;
var sessionStorageManager = new SessionStorageManager();

function handleSaveMode(saveMode, userGuid, successback, failback) {
    try {
        if (!_saveMode || _saveMode != saveMode)
        {
            _saveMode = saveMode;

            switch (_saveMode) {
                case CROSS_DOMAIN_METHOD.Cookies:
                    storageManager = new CookiesManager();
                    break;
                case CROSS_DOMAIN_METHOD.IndexedDB:
                    storageManager = new IndexedDBManager();
                    break;
                default:
                    storageManager = new LocalStorageManager();
                    break;
            }
        }

        storageManager.init(userGuid, successback);
    }
    catch (err) {
        if (failback) failback(err);
    }
}

function checkCanSave(callback) {
    storageManager.testConnection(callback);
}

function handleRequest(event)
{
    try {
        var data = _json.parse(event.data);

        if (data.toBC && channel) {
            channel.postMessage(data);
            return;
        }

        if (data.requestType == "checkCanSave")
        {
            handleSaveMode(data.saveMode, data.userGuid, function() {
                checkCanSave(function(result) {
                    event.source.postMessage(_json.stringify({key:data.requestType, canSave:result }), '*');
                });
            });
        }
        else if (data.requestType == "getAllMultiple")
        {
            getAllSavedDataMultiple(data.userGuid, function(value) {
                event.source.postMessage(_json.stringify({key:data.requestType, allValues:value}), '*');
            });
        }
        else if (data.requestType == "set")
        {
            storageManager.setItem(data.userGuid, data.key, data.saveObj);
        }
        else if (data.requestType == "delete")
        {
            storageManager.removeItem(data.userGuid, data.key);
        }
        else if (data.requestType == "add") {
            addToDictionary(data.userGuid, data.key, data.keyValues, data.saveObj);
        }
        else if (data.requestType == "addSet") {
            addToSet(data.userGuid, data.key, data.saveObj);
        }
        else if (data.requestType == 'get') {
            // Using handle save mode here is because the get method can be used without
            // initializing the storage manager
            handleSaveMode(data.saveMode, data.userGuid, function() {
                storageManager.getItem(data.userGuid, data.key, function(saveObj) {
                    if (saveObj) {
                        event.source.postMessage(_json.stringify({key:data.requestType, dataKey : data.key, saveObj:saveObj}), '*');
                    }
                });
            });
        }
        else if (data.requestType == "setSession") {
            sessionStorageManager.set(data);
        }
        else if (data.requestType == "getSession") {
            var value = sessionStorageManager.get(data);

            event.source.postMessage(_json.stringify({
                key : data.requestType,
                value : value,
                actionId : data.actionId
            }), '*');
        }
        else if (data.requestType == "increment") {
            storageManager.increment(data.userGuid, data.key, data.ttl, data.lastValue, function(newValue) {
                event.source.postMessage(_json.stringify({
                    key : data.requestType,
                    value : newValue,
                    actionId : data.actionId
                }), '*');
            });
        }
        else if (data.requestType == "getOrSetAndGet") {
            storageManager.getOrSetAndGet(data.userGuid, data.key, data.ttl, data.fallbackValue, function(newValue) {
                event.source.postMessage(_json.stringify({
                    key : data.requestType,
                    value : newValue,
                    actionId : data.actionId
                }), '*');
            });
        }
        else if (data.requestType == "terminate") {
            if (storageManager.terminate) {
                storageManager.terminate();
            }

            event.source.postMessage(_json.stringify({
                key : data.requestType
            }), '*');
        }
        else if (data.requestType == "remove") {
            removeFromDictionary(data.userGuid, data.key, data.keysToRemove, data.saveObj);
        }
        else if (data.requestType == "initBroadcastChannel") {
            return initBroadcastChannel();
        }
    }
    catch (err) {}
}

if(window.addEventListener) {
    window.addEventListener("message", handleRequest, false);
} else if (window.attachEvent) {
    window.attachEvent("onmessage", handleRequest);
}
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/storageManager.js ###*/
    /*### INCLUDE START /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/initializer.js ###*/
						function sendOriginMessageToParent() {
	window.postMessage && window.parent.postMessage(ORIGIN_MESSAGE, '*');
}

window.onload = sendOriginMessageToParent;
						/*### INCLUDE END /var/lib/jenkins/workspace/release-management/deployment/prod/deploy-player-prod/player/resources/CD/cdIframe/initializer.js ###*/
})();</script></body></html>